============================================================
STATSPHERE - REPORT SYSTEM (MODERATION)
============================================================
Files:
  Frontend: frontend/src/pages/Community.js
  Backend:  backend/api/modRoutes.js
  Database: backend/migrations/add_moderation.sql
============================================================

WHAT THE REPORT SYSTEM DOES
------------------------------
When a user sees a bad message in the community chat,
they can click the "Report" button next to the message.

A modal (popup) appears where they:
1. See which message they're reporting
2. Pick a category (Inappropriate, Harassment, Hate Speech, Spam, Other)
3. Type a reason explaining why they're reporting it
4. Click "Submit Report"

The report is saved in the database so admins can review it.

HOW IT WORKS (STEP BY STEP)
-----------------------------
FRONTEND (Community.js):
1. User clicks "Report" button next to a message
2. A modal popup appears with the message text
3. User selects a category from a dropdown
4. User types a reason in a text box
5. User clicks "Submit Report"
6. Frontend sends a POST request to the backend:
   POST /api/mod/report
   Body: { messageId, messageText, reason }
   Header: Authorization: Bearer <token>

BACKEND (modRoutes.js):
1. The requireAuth middleware checks the JWT token
2. If user is not logged in, return 401 error
3. If no reason is provided, return 400 error
4. Backend TRIES to insert the report into the database
5. If the table doesn't exist (PostgreSQL error 42P01),
   it creates the table and retries the insert
6. Returns { success: true, message: "Report submitted" }

This "try insert, create table if missing, retry" approach is
more reliable than always running CREATE TABLE IF NOT EXISTS,
because some cloud databases (like Supabase) may restrict
CREATE TABLE permissions.

DATABASE (add_moderation.sql):
  Table: reported_messages
  Columns:
  - id (auto-incrementing number)
  - reporter_user_id (who reported it)
  - message_id (ID of the chat message)
  - message_text (copy of the message text)
  - reason (why it was reported, includes category)
  - created_at (when the report was made)

KEY VARIABLES (Frontend)
--------------------------
  showReportModal   - true/false, controls if modal is visible
  reportMessage     - the message object being reported
  reportReason      - text the user typed as reason
  reportCategory    - dropdown: inappropriate, harassment, etc.
  reportLoading     - true while the report is being sent

KEY FUNCTIONS (Frontend)
--------------------------
  openReportModal(msg)  - shows the modal with the message
  closeReportModal()    - hides the modal and resets form
  submitReport()        - sends the report to the backend

KEY FUNCTIONS (Backend)
------------------------
  requireAuth(req, res, next) - checks JWT token is valid
  getUserFromToken(req)       - extracts user from JWT token
  isAdmin(email)              - checks if email is in ADMIN_EMAILS

ADMIN FEATURES
----------------
Admins can also:
  GET /api/mod/reports     - See all reports
  POST /api/mod/ban-user   - Ban a user from chatting
  POST /api/mod/unban-user - Unban a user

Admins are set in the .env file:
  ADMIN_EMAILS="admin@example.com,mod@example.com"

COMPLEX CODE EXPLAINED
------------------------
Here are the trickiest parts of this system in plain English:

1. requireAuth Middleware (checking JWT before route runs)
   In Express.js, middleware is a function that runs BEFORE the main route
   handler. requireAuth intercepts every request to protected routes (like
   /api/mod/report) and checks if the user sent a valid JWT token in the
   Authorization header. If the token is missing or invalid, it immediately
   sends back a 401 "Unauthorized" error and the route never runs. Think
   of it like a bouncer at a club door - you must show valid ID before
   you are allowed in. This keeps the report endpoint safe from people
   who are not logged in.

2. try-catch with Specific PostgreSQL Error Codes (42P01, 42703)
   The backend wraps the database INSERT inside a try-catch block. If the
   insert fails, it checks the specific PostgreSQL error code. Code 42P01
   means "table does not exist" (undefined_table) and 42703 means "column
   does not exist" (undefined_column). If the error is 42P01, the backend
   automatically creates the reported_messages table and retries the
   insert. This is smarter than always running CREATE TABLE IF NOT EXISTS
   because some cloud databases restrict table creation permissions, so
   we only attempt it when actually needed.

3. Table Auto-Creation Fallback
   This is a defensive programming pattern. Instead of assuming the
   database table always exists, the code tries the insert first (optimistic
   approach). If it fails because the table is missing, it creates the
   table on the fly and retries. This makes the app more resilient -
   it can recover from missing tables without crashing. It also means
   you do not need to run migration scripts manually before the app works.

DEFENCE TALKING POINTS
------------------------
Here is what to say when presenting the Report System:

- "The report flow works end-to-end: a user clicks Report, fills in a
  category and reason in a modal popup, the frontend sends a POST request
  with a JWT token, the backend middleware verifies authentication, and
  the report is stored in PostgreSQL. This demonstrates a complete
  full-stack feature from UI to database."

- "I used Express middleware (requireAuth) to protect the report endpoint.
  This is a standard pattern in production applications where certain
  routes should only be accessible to authenticated users."

- "The backend uses error-code-specific handling for PostgreSQL errors.
  If the reports table does not exist (error 42P01), it auto-creates
  the table and retries. This defensive approach means the app handles
  edge cases gracefully rather than just crashing."

- "The database schema stores the reporter's user ID, the message text,
  the reason for reporting, and a timestamp. This gives admins all the
  context they need to make moderation decisions."

- "I also built admin endpoints for viewing reports, banning users, and
  unbanning users. Admin access is controlled through an environment
  variable that lists admin email addresses, keeping it configurable
  without code changes."

============================================================

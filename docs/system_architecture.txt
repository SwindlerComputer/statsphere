============================================================
STATSPHERE - SYSTEM ARCHITECTURE
============================================================
Written for: Final Year Project Defence
============================================================

OVERVIEW
--------
StatSphere is a full-stack football statistics web application.
It has three main parts:

  1. Frontend  (React.js)  - What the user sees in the browser
  2. Backend   (Express.js) - The server that handles requests
  3. Database  (PostgreSQL / Supabase) - Where data is stored

Below is a simple diagram:

  +-------------------+         +--------------------+         +-------------------+
  |                   |  HTTP   |                    |  SQL    |                   |
  |   FRONTEND        | ------> |   BACKEND          | ------> |   DATABASE        |
  |   (React.js)      | <------ |   (Express.js)     | <------ |   (PostgreSQL)    |
  |                   |  JSON   |                    |  Rows   |                   |
  |   Port: 3000      |         |   Port: 5000       |         |   Port: 5432      |
  +-------------------+         +--------------------+         +-------------------+
         |                             |
         |  WebSocket (Socket.IO)      |
         +-----------------------------+
         (Real-time chat messages)


1. FRONTEND (React.js)
----------------------
Location: /frontend/src/

- Built with React.js (a JavaScript library for building user interfaces)
- Uses React Router for page navigation (no page refreshes needed)
- Styled with Tailwind CSS (utility-first CSS framework)
- Uses Recharts library for charts on the Player Insights page
- Uses Socket.IO Client for real-time chat

Key Files:
  - App.js         → Main router, navigation bar, layout
  - pages/         → Each page is a separate React component
    - Dashboard.js        → Homepage with live match data
    - Players.js          → Player statistics table with filters
    - PlayerInsights.js   → Player charts and AI analysis (NEW)
    - PlayerComparison.js → Compare two players side by side
    - BallonDor.js        → Ballon d'Or prediction rankings
    - Predictions.js      → Match outcome predictions
    - Community.js        → Real-time chat (WebSocket)
    - Login.js            → Login form
    - Register.js         → Registration form
    - LeagueStandings.js  → League table from API
    - LeagueFixtures.js   → Match fixtures from API

How it connects to the backend:
  - Uses fetch() to make HTTP requests (GET, POST)
  - API_BASE is set from environment variable: REACT_APP_API_URL
  - Locally: http://localhost:5000
  - Production: https://your-backend.onrender.com


2. BACKEND (Express.js / Node.js)
----------------------------------
Location: /backend/

- Built with Express.js (a Node.js web framework)
- Handles all API requests from the frontend
- Manages user authentication with JWT tokens
- Runs WebSocket server for real-time chat
- Serves data from JSON files and the database

Key Files:
  - server.js       → Main server file (routes, middleware, WebSocket)
  - db.js           → Database connection (supports Supabase + local)
  - auth/           → Authentication system
    - authRoutes.js     → Register, login, logout, /me endpoints
    - authMiddleware.js → JWT token verification middleware
  - api/            → API route handlers
    - footballApiRoutes.js → External football API integration
    - modRoutes.js         → Moderation (reports, bans)
  - data/           → JSON data files
    - players.json       → Original 6 players for Ballon d'Or
    - mockPlayers.json   → 200 mock players for Insights (NEW)
    - mockTeams.json     → 20 mock teams for Insights (NEW)
    - predictionTeams.json → Teams for match predictions
    - liveMatches.json     → Fake live match data

API Endpoints:
  - GET  /api/players           → Fetch original player stats
  - GET  /api/teams             → Fetch teams from database
  - GET  /api/insights/players  → Fetch 200 mock players (NEW)
  - GET  /api/insights/teams    → Fetch 20 mock teams (NEW)
  - POST /api/predict-match     → Predict match outcome
  - GET  /api/live-matches      → Get live match data
  - POST /auth/register         → Create new user account
  - POST /auth/login            → Log in and get JWT token
  - POST /auth/logout           → Clear JWT cookie
  - GET  /auth/me               → Get current logged-in user
  - POST /api/mod/report        → Report a chat message
  - GET  /api/mod/reports       → View all reports (admin)
  - POST /api/mod/ban-user      → Ban a user (admin)


3. DATABASE (PostgreSQL / Supabase)
------------------------------------
Location: /backend/migrations/

- Uses PostgreSQL as the relational database
- Can connect to local Postgres OR cloud Supabase
- Connection is configured in db.js using environment variables

Tables:
  - users              → Stores registered users (name, email, password hash)
  - teams              → Stores football teams
  - reported_messages  → Stores chat message reports

The database connection string is stored in the .env file
and NEVER committed to version control (for security).


4. EXTERNAL APIS
-----------------
- RapidAPI Football API → Provides real league standings and fixtures
- Accessed via /api/football routes
- API key stored in .env as RAPIDAPI_KEY


5. MACHINE LEARNING MODULE
----------------------------
Location: /ml/

- Written in Python using scikit-learn
- Trains a model to predict Ballon d'Or scores
- Uses features like goals, assists, xG, league weight
- Outputs predictions to CSV files

Key Files:
  - train.py    → Trains the ML model
  - predict.py  → Makes predictions with trained model
  - features.py → Feature engineering functions


DATA FLOW EXAMPLE (Viewing Player Insights):
----------------------------------------------
1. User opens /insights page in browser
2. React component (PlayerInsights.js) mounts
3. useEffect() sends GET request to backend: /api/insights/players
4. Express route handler reads mockPlayers.json file
5. Returns JSON array of 200 players to frontend
6. User selects a player from dropdown
7. Recharts renders bar chart and radar chart
8. Rule-based system analyses stats and shows strengths/weaknesses
9. All happens in the browser - no further server requests needed


DEPLOYMENT
----------
- Frontend: Deployed on Render (or any static hosting)
- Backend: Deployed on Render (Node.js web service)
- Database: Hosted on Supabase (cloud PostgreSQL)
- Environment variables configured on Render dashboard

COMPLEX CODE EXPLAINED
-----------------------

1. HOW THE FRONTEND TALKS TO THE BACKEND (fetch API)

   From App.js - checking if the user is logged in when the app loads:

     fetch(API_BASE + "/auth/me", {
       credentials: "include",
       headers: savedToken ? { "Authorization": "Bearer " + savedToken } : {}
     })
       .then(function (res) { return res.json(); })
       .then(function (data) {
         if (data.user) {
           setUser(data.user);
         }
       })

   Line by line:
   - fetch(API_BASE + "/auth/me", {...})
     This sends an HTTP GET request to the backend. API_BASE is the backend
     URL (e.g. http://localhost:5000). So the full URL becomes
     http://localhost:5000/auth/me.
   - credentials: "include"
     This tells the browser to send cookies along with the request. Without
     this, the backend would not receive the login cookie.
   - headers: savedToken ? { "Authorization": "Bearer " + savedToken } : {}
     This is a backup. If cookies are blocked (e.g. incognito mode), it sends
     the token in the request header instead. The "Bearer" prefix is a standard
     format that servers expect.
   - .then(function (res) { return res.json(); })
     fetch() returns a Response object. Calling .json() reads the response
     body and converts it from a JSON string into a JavaScript object.
   - .then(function (data) { if (data.user) { setUser(data.user); } })
     If the backend returned a user object (meaning the token was valid),
     we save it in React state so the whole app knows who is logged in.

2. HOW THE BACKEND CONNECTS TO THE DATABASE (Connection Pool)

   From db.js:

     import pkg from "pg";
     const { Pool } = pkg;

     pool = new Pool({
       connectionString: process.env.SUPABASE_DATABASE_URL,
       ssl: { rejectUnauthorized: false },
     });

   Line by line:
   - import pkg from "pg"
     "pg" is the PostgreSQL library for Node.js. It lets JavaScript talk
     to a PostgreSQL database.
   - const { Pool } = pkg
     A Pool is a collection of reusable database connections. Instead of
     opening a new connection every time (which is slow), the pool keeps
     several connections ready to use. Think of it like a car rental desk
     with multiple cars - you grab one, use it, return it.
   - new Pool({ connectionString: process.env.SUPABASE_DATABASE_URL, ... })
     This creates the pool using a connection string from the .env file.
     The connection string contains the database address, username, password,
     and database name all in one URL.
   - ssl: { rejectUnauthorized: false }
     SSL encrypts the connection between our server and the database.
     This is required for cloud databases like Supabase. The
     "rejectUnauthorized: false" part allows self-signed certificates.

3. HOW WEBSOCKET DIFFERS FROM HTTP

   HTTP (normal requests) from server.js:
     app.get("/api/players", (req, res) => {
       const jsonData = fs.readFileSync(filePath, "utf8");
       res.json(JSON.parse(jsonData));
     });

   WebSocket (real-time) from server.js:
     io.on("connection", async (socket) => {
       socket.emit("chat_history", chatMessages);
       socket.on("send_message", async (messageText) => {
         io.emit("new_message", newMessage);
       });
     });

   The difference:
   - HTTP: The client (browser) sends a request, the server sends ONE response,
     and the connection closes. The client must ask again to get new data.
   - WebSocket: The connection stays OPEN after the initial handshake. The
     server can push data to the client at any time using io.emit(), and the
     client can send data using socket.emit(). Neither side has to wait for
     the other to ask first.
   - io.emit("new_message", newMessage) sends the message to ALL connected
     users at once - this is what makes the chat feel "real-time".


DEFENCE TALKING POINTS
-----------------------

- "I chose a separated frontend-backend architecture because it follows
  industry best practices. The React frontend handles what the user sees,
  while the Express backend handles business logic and data. This means I
  could deploy them independently - the frontend on Vercel and the backend
  on Render - and they communicate through a REST API using JSON. If I
  ever wanted to build a mobile app, it could use the same backend API
  without any changes."

- "I chose PostgreSQL as the database because it is a production-grade
  relational database used by companies like Instagram and Spotify. It
  supports structured queries with SQL, has strong data integrity with
  foreign keys, and scales well. I hosted it on Supabase which gives me
  a cloud PostgreSQL instance for free, so the app works from anywhere
  without needing a local database running."

- "The data flow in my app follows a clear path: the user interacts with
  the React frontend, which sends HTTP requests to the Express backend
  using the fetch API. The backend either reads from JSON files for static
  data or queries the PostgreSQL database for dynamic data like user
  accounts. It then sends a JSON response back to the frontend, which
  updates what the user sees using React state. For real-time features
  like chat, I use WebSockets instead of HTTP so that messages are pushed
  to all users instantly without them having to refresh."

- "I used a connection pool for the database rather than individual
  connections. A pool keeps several database connections ready to reuse,
  which is much faster than opening a new connection for every request.
  This is important for performance when multiple users are using the
  app at the same time."

- "My application uses three communication methods: HTTP GET requests
  for reading data, HTTP POST requests for sending data like login forms,
  and WebSockets for real-time bidirectional communication in the chat.
  Each method is suited to its purpose - you would not use WebSockets
  for loading a player list, and you would not use HTTP polling for
  a live chat."

============================================================
END OF DOCUMENT
============================================================


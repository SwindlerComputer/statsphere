============================================================
STATSPHERE - AUTHENTICATION FLOW (JWT LOGIN SYSTEM)
============================================================
Written for: Final Year Project Defence
============================================================

OVERVIEW
--------
StatSphere uses JSON Web Tokens (JWT) for user authentication.
JWT is a standard way to securely identify users without storing
session data on the server.

Key Files:
  - backend/auth/authRoutes.js     → Register, login, logout, /me
  - backend/auth/authMiddleware.js → Verifies JWT tokens
  - frontend/src/App.js            → Checks if user is logged in
  - frontend/src/pages/Login.js    → Login form
  - frontend/src/pages/Register.js → Registration form


WHAT IS JWT?
------------
JWT stands for "JSON Web Token". It is a small encoded string that
contains user information (like their ID and email).

A JWT looks like this:
  eyJhbGciOiJIUzI1NiJ9.eyJpZCI6MSwiZW1haWwiOiJ0ZXN0QGVtYWlsLmNvbSJ9.abc123

It has 3 parts separated by dots:
  1. Header  → Algorithm used (HS256)
  2. Payload → User data (id, email, name)
  3. Signature → Secret key verification (prevents tampering)

The server creates the token using a SECRET KEY stored in the .env file.
Only the server knows the secret, so no one can fake a token.


REGISTRATION FLOW
------------------
1. User fills in name, email, password on the Register page
2. Frontend sends POST request to /auth/register
3. Backend checks:
   - Are all fields provided?
   - Is the password at least 8 characters?
   - Is the email already registered?
4. Password is HASHED using bcrypt (never stored as plain text!)
   - Example: "password123" → "$2b$10$x7dJ..."
   - Hashing is one-way: you cannot reverse it
5. New user is saved to the database (users table)
6. JWT token is created containing user ID, email, and name
7. Token is sent back in TWO ways:
   a. As an HTTP-only cookie (browser stores it automatically)
   b. In the response body (stored in localStorage as backup)
8. User is now logged in!

Flow Diagram:
  [User] → Register Form → POST /auth/register → [Backend]
  [Backend] → Validate → Hash Password → Save to DB → Create JWT
  [Backend] → Set Cookie + Return Token → [User is logged in]


LOGIN FLOW
-----------
1. User enters email and password on the Login page
2. Frontend sends POST request to /auth/login
3. Backend checks:
   - Does a user with this email exist?
   - Does the password match the hash? (using bcrypt.compare)
4. If valid, a new JWT token is created
5. Token is sent as a cookie AND in the response body
6. Frontend stores the token and redirects to dashboard

Flow Diagram:
  [User] → Login Form → POST /auth/login → [Backend]
  [Backend] → Find User → Compare Password Hash → Create JWT
  [Backend] → Set Cookie + Return Token → [User is logged in]


HOW THE APP KNOWS YOU ARE LOGGED IN
-------------------------------------
When the app first loads (App.js), it runs a useEffect() that:
1. Gets the saved token from localStorage (if any)
2. Sends GET request to /auth/me with the token
3. Backend verifies the JWT token using the secret key
4. If valid, returns the user object (id, name, email)
5. Frontend stores the user in React state
6. Navigation bar shows "Logged in as: [name]"

If the token is expired or invalid, the user sees the Login link instead.

Flow Diagram:
  [App Loads] → GET /auth/me (with token) → [Backend]
  [Backend] → Verify JWT → Query DB → Return user object
  [Frontend] → setUser(data.user) → Show logged-in UI


LOGOUT FLOW
------------
1. User clicks the Logout button in the navbar
2. Frontend sends POST request to /auth/logout
3. Backend clears the JWT cookie using res.clearCookie()
4. Frontend removes token from localStorage
5. Frontend sets user to null and redirects to homepage
6. User is now logged out!


WHY TWO TOKEN STORAGE METHODS?
-------------------------------
We store the JWT in both a cookie AND localStorage because:

1. Cookies: The preferred method
   - httpOnly: true → JavaScript cannot read the cookie (more secure)
   - Automatically sent with every request
   - But: Some browsers block third-party cookies (especially in incognito)

2. localStorage: The backup method
   - Works even when cookies are blocked
   - Sent manually via Authorization header: "Bearer <token>"
   - Less secure than httpOnly cookies (JavaScript can access it)

This dual approach ensures the app works in all browsers and modes.


PASSWORD SECURITY
-----------------
- Passwords are NEVER stored as plain text
- bcrypt hashing with salt rounds = 10
- bcrypt.hash("password123", 10) → "$2b$10$randomSaltAndHash..."
- Each password gets a unique random salt
- Even if the database is leaked, passwords cannot be read
- bcrypt.compare() checks if a password matches its hash


COOKIE SETTINGS EXPLAINED
--------------------------
res.cookie("token", token, {
  httpOnly: true,     → Cannot be read by JavaScript (XSS protection)
  sameSite: "none",   → Allows cross-site cookies (needed for deployment)
  secure: true,       → Cookie only sent over HTTPS (production)
  maxAge: 7 days      → Cookie expires after 7 days
});

In local development:
  sameSite: "lax"   → Normal browser behaviour
  secure: false     → HTTP is fine locally (no HTTPS needed)


JWT SECRET
----------
The JWT_SECRET is a random string stored in the .env file.
Example: JWT_SECRET=my_super_secret_key_12345

This secret is used to:
1. CREATE tokens (jwt.sign)
2. VERIFY tokens (jwt.verify)

If someone doesn't know the secret, they CANNOT create valid tokens.
This is why the .env file must NEVER be shared or committed to Git.

COMPLEX CODE EXPLAINED
-----------------------

1. JWT TOKEN CREATION (jwt.sign)

   From authRoutes.js:

     function createToken(user) {
       var tokenData = {
         id: user.id,
         email: user.email,
         name: user.name
       };
       var token = jwt.sign(tokenData, process.env.JWT_SECRET, { expiresIn: "7d" });
       return token;
     }

   Line by line:
   - function createToken(user)
     This helper function takes a user object (from the database) and
     creates a JWT token for them.
   - var tokenData = { id: user.id, email: user.email, name: user.name }
     This is the "payload" - the data we want to store INSIDE the token.
     We include the user's ID, email, and name so the backend can identify
     them later without querying the database every time.
   - jwt.sign(tokenData, process.env.JWT_SECRET, { expiresIn: "7d" })
     jwt.sign() does three things:
       1. Takes the tokenData and converts it to a JSON string
       2. Encrypts/signs it using the JWT_SECRET (a random string only
          the server knows, stored in the .env file)
       3. Sets it to expire in 7 days ("7d")
     The result is a long encoded string like "eyJhbG...abc123" that
     the browser stores and sends back with every request.
   - Nobody can fake this token because they do not know the JWT_SECRET.
     If someone changes even one character, jwt.verify() will reject it.

2. PASSWORD HASHING (bcrypt)

   From authRoutes.js - during registration:

     var hash = await bcrypt.hash(password, 10);

   From authRoutes.js - during login:

     var passwordIsCorrect = await bcrypt.compare(password, user.password_hash);

   Line by line:
   - bcrypt.hash(password, 10)
     This takes the plain text password (e.g. "MyPassword1") and runs it
     through bcrypt's hashing algorithm. The number 10 is the "salt rounds"
     - it means bcrypt will run its algorithm 2^10 (1024) times, making it
     very slow to crack by brute force. The result looks like:
     "$2b$10$x7dJ3kLmN..." - a long random-looking string.
   - await - hashing is an async operation because it is intentionally slow
     (for security). We use await to wait for it to finish.
   - bcrypt.compare(password, user.password_hash)
     During login, we CANNOT reverse the hash to get the original password.
     Instead, bcrypt.compare() takes the password the user just typed,
     hashes it using the same salt that was stored, and checks if the
     result matches the stored hash. It returns true if they match,
     false if they do not.
   - Each password gets a unique random "salt" mixed in, so even if two
     users have the same password, their hashes will be completely different.

3. COOKIE + LOCALSTORAGE DUAL STORAGE

   From authRoutes.js - after successful login or registration:

     res.cookie("token", token, getCookieOptions());
     res.json({ message: "Logged in", user: user, token: token });

   From authMiddleware.js - checking who the user is:

     let token = req.cookies.token;
     if (!token && req.headers.authorization) {
       const parts = req.headers.authorization.split(" ");
       if (parts[0] === "Bearer" && parts[1]) {
         token = parts[1];
       }
     }

   Line by line:
   - res.cookie("token", token, getCookieOptions())
     This sets an HTTP-only cookie in the user's browser. The browser stores
     it automatically and sends it with every request. httpOnly: true means
     JavaScript on the page CANNOT read this cookie, which protects against
     XSS attacks (malicious scripts stealing the token).
   - res.json({ ..., token: token })
     We ALSO send the token in the response body. The frontend stores this
     in localStorage as a backup. This is needed because some browsers
     (especially in incognito mode) block third-party cookies.
   - In authMiddleware.js: it first tries req.cookies.token (the cookie).
     If that is empty, it checks req.headers.authorization for a "Bearer"
     token (from localStorage). This way, authentication works regardless
     of whether cookies are enabled or not.


DEFENCE TALKING POINTS
-----------------------

- "I chose JWT (JSON Web Tokens) over traditional server-side sessions
  because JWT is stateless. The server does not need to store session data
  in memory or a database. The token itself contains all the user info
  needed, signed with a secret key. This makes the system more scalable
  because any server instance can verify the token independently, which
  is important for cloud deployment."

- "Passwords are never stored as plain text in my database. I use bcrypt
  with 10 salt rounds to hash every password before saving it. Bcrypt is
  specifically designed for password hashing - it is intentionally slow,
  which makes brute-force attacks impractical. Even if someone gained
  access to the database, they would only see hashes like '$2b$10$x7dJ...'
  which cannot be reversed back to the original password."

- "My token expiry is set to 7 days. This is a balance between security
  and user convenience. After 7 days, the token becomes invalid and the
  user must log in again. This limits the damage if a token is ever stolen.
  The jwt.verify() function automatically checks the expiry date and
  rejects expired tokens, so the app handles this without any extra code."

- "I implemented a dual storage strategy for the JWT token - it is stored
  in both an httpOnly cookie and localStorage. The cookie is the primary
  method because httpOnly prevents JavaScript from reading it, protecting
  against XSS attacks. localStorage is the fallback for browsers that
  block cookies. The authMiddleware checks both locations, ensuring the
  app works in all browsers and incognito mode."

- "The authentication middleware pattern means I write the token verification
  logic once and reuse it across all protected routes. Any route that needs
  a logged-in user just adds the middleware function, and if the token is
  invalid, the request is rejected before it ever reaches the route handler.
  This is the standard approach used in production Express.js applications."

============================================================
END OF DOCUMENT
============================================================


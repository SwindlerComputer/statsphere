============================================================
STATSPHERE - COMMUNITY CHAT PAGE
============================================================
File: frontend/src/pages/Community.js
URL: /community
============================================================

WHAT THIS PAGE DOES
--------------------
This is a real-time chat page where logged-in users can
talk to each other. Messages appear instantly (no need to
refresh the page) because we use WebSockets.

HOW IT WORKS (STEP BY STEP)
-----------------------------
1. User must be logged in to use the chat.
   If not logged in, they see a message saying
   "Please log in to join the community chat."

2. When the page loads, it connects to the backend
   using Socket.IO (a WebSocket library).

3. When the user types a message and clicks "Send":
   a. The message is sent to the backend via WebSocket
   b. The backend receives it
   c. The backend checks for bad words (moderation)
   d. The backend sends the message to ALL connected users
   e. Everyone's chat updates instantly

4. Messages appear in a scrollable list with:
   - The sender's name
   - The message text
   - The time it was sent

WEBSOCKETS vs NORMAL HTTP
---------------------------
Normal HTTP (what we use for other pages):
  - Client asks server for data (request)
  - Server sends data back (response)
  - Connection closes
  - Client has to ask again to get updates

WebSocket (what we use for chat):
  - Client connects to server (stays connected)
  - Server can send data to client at ANY TIME
  - Client can send data to server at ANY TIME
  - Perfect for chat because messages appear instantly

SOCKET.IO EXPLAINED
---------------------
Socket.IO is a library that makes WebSockets easy to use.

Backend (server.js):
  const io = require("socket.io")(server)
  io.on("connection", (socket) => {
    socket.on("chat-message", (msg) => {
      io.emit("chat-message", msg)
    })
  })

Frontend (Community.js):
  import io from "socket.io-client"
  const socket = io(API_BASE)
  socket.on("chat-message", (msg) => {
    // add message to the chat list
  })

The key events:
  "connection": A user has joined the chat
  "chat-message": A new message was sent
  "disconnect": A user left the chat

MODERATION SYSTEM
-------------------
Before a message is sent to everyone, the backend checks it.
If the message contains a bad word, it gets blocked.

The system also allows users to "report" a message.
If a message gets enough reports, it can be reviewed
by an admin.

See moderation_system.txt for more details.

KEY REACT CONCEPTS USED
-------------------------
- useState: Stores messages, input text
- useEffect: Connects to WebSocket when page loads
- useRef: Scrolls chat to the bottom when new messages arrive

COMPLEX CODE EXPLAINED
------------------------
Here are the trickiest parts of this page in plain English:

1. Socket.IO Connection (the io() function)
   When the page loads, the line "const socket = io(API_BASE)" opens a
   permanent connection to the server. Think of it like a phone call that
   stays on the line. Unlike a normal web request (which hangs up after
   getting a response), this connection stays open so the server can push
   new messages to you instantly. The io() function handles reconnecting
   automatically if the connection drops.

2. emit/on Events (sending and receiving messages)
   Socket.IO uses an event system. "socket.emit('chat-message', msg)"
   is like shouting a message into the phone. "socket.on('chat-message',
   callback)" is like listening for someone else to shout. The server
   listens for messages from any user and then broadcasts them to ALL
   connected users using "io.emit()". This is how everyone sees every
   message in real time without refreshing.

3. Auto-scroll with useRef
   useRef creates a reference to an invisible element at the bottom of
   the chat list. Every time a new message arrives, we call
   "messagesEndRef.current.scrollIntoView()" which tells the browser
   to scroll down to that invisible element. This keeps the chat scrolled
   to the newest message automatically, just like WhatsApp or iMessage.

DEFENCE TALKING POINTS
------------------------
Here is what to say when presenting the Community Chat feature:

- "I implemented real-time communication using Socket.IO, which maintains
  a persistent WebSocket connection between the client and server. This
  means messages are delivered instantly without the user needing to
  refresh the page, similar to how professional chat apps like Slack work."

- "When a user sends a message, the frontend emits it to the server, and
  the server broadcasts it to every connected client. This publish-subscribe
  pattern is a standard approach for real-time features in modern web apps."

- "I added a report system so users can flag inappropriate messages. This
  shows I thought about user safety and moderation, not just features."

- "The chat automatically scrolls to the latest message using a React
  useRef hook, which gives a smooth user experience without manual
  scrolling."

- "I chose Socket.IO over raw WebSockets because it provides automatic
  reconnection, fallback to HTTP polling if WebSockets are blocked, and
  a simple event-based API that made development faster."

============================================================

============================================================
STATSPHERE - WEBSOCKET REAL-TIME CHAT SYSTEM
============================================================
Written for: Final Year Project Defence
============================================================

OVERVIEW
--------
StatSphere has a real-time community chat feature built with
WebSockets using the Socket.IO library. This allows users to
send and receive messages instantly without refreshing the page.

Key Files:
  - backend/server.js              → WebSocket server setup
  - frontend/src/pages/Community.js → Chat page UI

MULTIPLE CHAT ROOMS
-------------------
The chat has 4 rooms: General Chat, Ballon d'Or, Transfers, GOAT Debate.
Each room has its own message list. The server stores messages per room in
an object: chatMessages["general"], chatMessages["ballon-dor"], etc.
When a user joins a room (join_room event), the server sends that room's
history. When a user sends a message, the server broadcasts it only to
users in that room using io.to(roomId).emit("new_message", message).
See pages_community_chat.txt for full details.


WHAT ARE WEBSOCKETS?
---------------------
Normal HTTP (like fetch/axios):
  - Client sends a request → Server responds → Connection closes
  - Client must ask again to get new data (polling)
  - Like sending a letter and waiting for a reply

WebSockets:
  - Client opens a connection → Connection stays OPEN
  - Server can push data to client anytime
  - Client can send data to server anytime
  - Like a phone call - both sides can talk at any time

This makes WebSockets perfect for:
  - Chat applications (instant messages)
  - Live scores (real-time updates)
  - Notifications (push to user)
  - Multiplayer games

Comparison:
  HTTP:       Client → Server → Response → Connection Closed
  WebSocket:  Client ↔ Server (always connected, both can send anytime)


WHAT IS SOCKET.IO?
-------------------
Socket.IO is a JavaScript library that makes WebSockets easy to use.
It works on both the server (Node.js) and client (browser).

- Server: const io = new Server(httpServer)
- Client: const socket = io("http://localhost:5000")

Socket.IO adds features on top of raw WebSockets:
  - Automatic reconnection (if connection drops)
  - Event-based messaging (named events like "send_message")
  - Room support (group users into channels)
  - Fallback to HTTP polling (if WebSockets aren't supported)


HOW THE CHAT WORKS - STEP BY STEP
------------------------------------

STEP 1: SERVER SETUP (server.js)
  - Create HTTP server from Express app
  - Attach Socket.IO to the HTTP server
  - Configure CORS to allow frontend connections
  - Store messages per room in an object (chatMessages["general"] = [], etc.)

STEP 2: USER CONNECTS (Community.js)
  - When user opens the Community page, a WebSocket connection is created:
      let newSocket = io(API_BASE, { withCredentials: true })
  - The server detects the connection:
      io.on("connection", (socket) => { ... })
  - Server tries to identify the user using their JWT token (from cookie)
  - Client emits "join_room", roomId (e.g. "general"); server runs socket.join(roomId)
    and sends that room's history: socket.emit("chat_history", chatMessages[roomId])

STEP 3: USER SENDS A MESSAGE
  - User types a message and clicks Send
  - Frontend sends the message and current room via WebSocket:
      socket.emit("send_message", { room: currentRoom, text: messageText })
  - Server receives it and validates:
      a. Is the user logged in?
      b. Is the user banned?
      c. Is the message empty?
      d. Is the message too long? (max 200 characters)
      e. Is the user sending too fast? (rate limit: 2 seconds)
  - Server censors bad words (replaces with ***)
  - Server creates a message object and pushes it to chatMessages[roomId]
  - Server sends the message only to users in that room:
      io.to(roomId).emit("new_message", newMessage)

STEP 4: ALL USERS RECEIVE THE MESSAGE
  - Every connected client has a listener:
      socket.on("new_message", (message) => { ... })
  - React adds the message to the messages array
  - The new message appears in everyone's chat instantly

STEP 5: USER DISCONNECTS
  - When user leaves the page or closes the browser
  - The cleanup function runs: newSocket.disconnect()
  - Server detects: socket.on("disconnect", () => { ... })


MESSAGE FLOW DIAGRAM
---------------------

  User A types "Hello!"
        |
        v
  [Frontend] socket.emit("send_message", "Hello!")
        |
        v
  [Server] Validates → Censors → Creates message object
        |
        v
  [Server] io.emit("new_message", { text: "Hello!", userName: "A", ... })
        |
        +-------+-------+-------+
        |       |       |       |
        v       v       v       v
     User A  User B  User C  User D
   (all see "Hello!" appear instantly)


SOCKET.IO EVENTS USED
-----------------------
Server → Client:
  - "chat_history"  → Sends all existing messages when user connects
  - "new_message"   → Sends a new message to all connected users
  - "error_message" → Sends an error (e.g. "You must be logged in")

Client → Server:
  - "send_message"  → Sends a new chat message

Built-in Events:
  - "connection"    → Triggered when a user connects
  - "disconnect"    → Triggered when a user disconnects


AUTHENTICATION IN WEBSOCKETS
------------------------------
WebSockets don't have HTTP headers like normal requests.
So we authenticate users by:

1. Checking the cookie attached to the WebSocket handshake:
     socket.handshake.headers.cookie → parse → get JWT token

2. As a backup, checking the auth object:
     socket.handshake.auth.token → JWT token from localStorage

3. Verifying the JWT token with jwt.verify()

4. Looking up the user in the database

5. Storing user info on the socket: socket.user = user


MESSAGE STORAGE
---------------
Currently, messages are stored in a JavaScript array in server memory:
  let chatMessages = []

This means:
  - Messages are fast to read/write (no database queries)
  - Messages are LOST when the server restarts
  - Only the last 50 messages are kept (to prevent memory overflow)

In a production system, you would store messages in a database.


RATE LIMITING
--------------
To prevent spam, the server tracks when each user last sent a message:
  let lastMessageTime = { userId: timestamp }

If a user tries to send another message within 2 seconds:
  - The message is rejected
  - User receives: "Please wait 2 seconds before sending another message"

COMPLEX CODE EXPLAINED
-----------------------

1. SOCKET.IO CONNECTION SETUP

   Server side (server.js):

     const httpServer = createServer(app);
     const io = new Server(httpServer, {
       cors: {
         origin: process.env.FRONTEND_URL || "http://localhost:3000",
         credentials: true
       }
     });

   Client side (Community.js):

     var newSocket = io(API_BASE, {
       withCredentials: true,
       auth: savedToken ? { token: savedToken } : {}
     });

   Line by line:
   - const httpServer = createServer(app)
     Normally Express uses app.listen() to start the server. But Socket.IO
     needs access to the raw HTTP server, so we create it manually using
     Node's built-in createServer() and pass the Express app into it.
     This lets both REST API routes and WebSocket connections share the
     same server and port.
   - new Server(httpServer, { cors: {...} })
     This creates the Socket.IO server and attaches it to our HTTP server.
     The cors setting allows the frontend (on a different port or domain)
     to connect. credentials: true allows cookies to be sent during the
     WebSocket handshake.
   - io(API_BASE, { withCredentials: true, auth: { token: savedToken } })
     On the client side, io() connects to the backend's WebSocket server.
     withCredentials: true sends cookies, and auth: { token } sends the
     JWT token as a backup (for when cookies are blocked). This connection
     stays open as long as the user is on the chat page.

2. REAL-TIME EVENT HANDLING (emit/on pattern)

   Sending a message (Community.js):

     socket.emit("send_message", newMessage);

   Server receiving and broadcasting (server.js):

     socket.on("send_message", async (messageText) => {
       const censoredText = censorMessage(messageText.trim());
       let newMessage = {
         id: Date.now(),
         text: censoredText,
         userName: socket.user.name,
         timestamp: new Date().toISOString()
       };
       io.emit("new_message", newMessage);
     });

   Client receiving (Community.js):

     newSocket.on("new_message", function (message) {
       setMessages(function (prev) { return prev.concat(message); });
     });

   Line by line:
   - socket.emit("send_message", newMessage)
     emit() sends a named event through the WebSocket connection. Think of
     "send_message" as a channel name. The second argument is the data
     being sent (the message text).
   - socket.on("send_message", async (messageText) => {...})
     on() listens for a named event. When the server hears "send_message",
     it runs this callback function with the data that was sent.
   - The server censors bad words, creates a message object with an ID,
     username, and timestamp, then calls io.emit("new_message", newMessage).
   - io.emit() vs socket.emit(): This is the key difference.
     socket.emit() sends to ONE user. io.emit() sends to ALL connected
     users. This is what makes the chat real-time - when one person sends
     a message, EVERYONE receives it instantly.
   - On the client side, on("new_message") fires for every connected user.
     It uses setMessages with a callback (prev.concat(message)) to safely
     add the new message to the existing array without losing any data.

3. CHAT HISTORY LOADING

   Server side (server.js) - when a user first connects:

     io.on("connection", async (socket) => {
       socket.emit("chat_history", chatMessages);
     });

   Client side (Community.js) - receiving the history:

     newSocket.on("chat_history", function (history) {
       setMessages(history);
       setLoading(false);
     });

   Line by line:
   - io.on("connection", async (socket) => {...})
     This fires every time a new user connects via WebSocket. The socket
     parameter represents that specific user's connection.
   - socket.emit("chat_history", chatMessages)
     Immediately after connecting, the server sends ALL existing messages
     to ONLY this new user (socket.emit, not io.emit). chatMessages is a
     JavaScript array stored in server memory that holds the last 50
     messages.
   - On the client, on("chat_history") receives the array of messages,
     saves them to React state with setMessages(history), and sets
     loading to false so the loading spinner disappears.
   - This means when you open the chat page, you instantly see the recent
     conversation history, then any new messages appear in real-time
     after that.


DEFENCE TALKING POINTS
-----------------------

- "I chose WebSockets over HTTP polling for the chat feature because
  polling would require the frontend to send a request every few seconds
  asking 'are there new messages?' - this wastes bandwidth and adds
  latency. With WebSockets, the connection stays open and the server
  pushes new messages to all clients instantly. This is how professional
  chat applications like Slack and Discord work."

- "The real-time communication uses an event-driven pattern with emit()
  and on(). The client emits a 'send_message' event, the server processes
  it and then emits a 'new_message' event to all connected clients. This
  publish-subscribe model means the server acts as a central hub that
  distributes messages to everyone. I used Socket.IO rather than raw
  WebSockets because it adds automatic reconnection, fallback to HTTP
  polling if WebSockets are not supported, and a clean event-based API."

- "The difference between my REST API and WebSocket communication is
  fundamental. REST API (fetch) follows a request-response model - the
  client asks and the server answers, then the connection closes. WebSocket
  is bidirectional - both sides can send data at any time over a persistent
  connection. I use REST for things like loading player data (which only
  needs to happen once) and WebSocket for chat (which needs continuous
  real-time updates)."

- "I implemented several safety features in the chat: rate limiting
  prevents spam by requiring a 2-second gap between messages, message
  length is capped at 200 characters, banned words are automatically
  censored, and banned users are blocked from sending. All validation
  happens on the server side so it cannot be bypassed by modifying the
  frontend code."

- "Messages are currently stored in server memory for simplicity, which
  means they are lost on server restart. In a production system, I would
  store them in the PostgreSQL database. However, the in-memory approach
  is faster for a prototype and demonstrates the core real-time
  communication pattern."

============================================================
END OF DOCUMENT
============================================================

